# creates a matrix where the column number is the number of the tile.
# the the entries of that column show which tiles are the adjacent to the current tile.
grid.maker = function(n) {
  mat = matrix(ncol=n^2, nrow=8)
  for(i in 1:n^2) {
    if((i == 1) | (i == n) | (i == n*(n-1)+1) | (i == n^2)) {
      #corner
      if (i==1){
        mat[,i]=c(2,n+1,n+2, NA, NA, NA, NA, NA)
      } else if(i==n){
        mat[,i]=c(n-1,2*n-1,2*n, NA, NA, NA, NA, NA)
      } else if(i==n*(n-1)+1){
        mat[,i]=c(n*(n-2)+1, n*(n-2)+2, n*(n-1)+2, NA, NA, NA, NA, NA)
      } else if(i==n^2){
        mat[,i]=c(n*(n-1)-1, n*(n-1), n^2-1, NA, NA, NA, NA, NA)
      }
    }    else if(i %in% 2:(n-1)) {
      #top
      mat[,i]=c(i-1,i+1,i+n-1, i+n, i+n+1, NA, NA, NA)
    }    else if(i%%n == 1){
      #left
      mat[,i]=c(i-n,i-n+1, i+1, i+n, i+n+1, NA, NA, NA)
    }    else if(i%%n == 0){
      #right
      mat[,i]=c(i-n-1,i-n, i-1, i+n-1, i+n, NA, NA, NA)
    }    else if(i %in% (n*(n-1)+2:n^2-1)){
      #bot
      mat[,i]=c(i-n-1, i-n, i-n+1, i-1, i+1, NA, NA, NA)
    }    else{
      #center
      mat[,i]=c(i-n-1, i-n, i-n+1, i-1, i+1, i+n-1, i+n, i+n+1)
    }
  }
  return(mat)
}

# actually returns the vector of tiles (the tile numbers) adjacent to the current tile
# jumpmat is defined below in the user steps, which was generated from grid.maker function
jumper = function(num, rock1) {
  jump = jumpmat[,num]
  jump[!(jump %in% rock1)]
}

# adds water to your matrix containing the number of droplets of water on each tile,
# which is called dropmat1. The dropvec is the vector determining which tiles will
# receive drops. Wateramt is the average amount of eachwater dropped on each tile
# generated by an exponential distribution.
cloud=function(dropmat1, dropvec, wateramt){
  n = dim(dropmat1)[1]
  for(i in dropvec){
    dropmat1[ifelse(i%%n==0, i%/%n, i%/%n+1), ifelse(i%%n==0,n,i%%n)] = 
      dropmat1[ifelse(i%%n==0, i%/%n, i%/%n+1), ifelse(i%%n==0,n,i%%n)] +
      rexp(1, 1/wateramt)
  }
  return (dropmat1)
}

# this function looks at adjacent tiles and determine which tiles will receive water
# water can only travel into adjacent tiles that have less water than the current tile.
direcflow=function(tile, dropmat1, rock1){
  adjaflow = numeric()
  n=dim(dropmat1)[1]
  adjapos = jumper(tile, rock1)
  for(i in adjapos[!is.na(adjapos)]){
    if(dropmat1[ifelse(tile%%n==0, tile%/%n, tile%/%n+1), ifelse(tile%%n==0,n,tile%%n)] >
         dropmat1[ifelse(i%%n==0, i%/%n, i%/%n+1), ifelse(i%%n==0,n,i%%n)]) {
      adjaflow= c(adjaflow, i)      
    }
  }
  return(adjaflow)
}

# to solve simultaneity and bias problems, this function moves only a very little
# portion of water in 1 time (let's call "small time"). This function only works on
# 1 tile at the time. Rate1 controls how quickly disequilibrium of water should 
# return to equilibrium. If rate1=1, then equilibrium should be almost achieved in 
# 1 "big time". If rate1=2, then equilibrium should be almost achieved in 2 
# "big time." Rate2 is similar to rate1--it controls how fast equilibrium should 
# be reached. However, rate2 is also the number of cycles of "small time" in 1 
# "big time"

one.small.time.flow = function(tile, rate1, rate2, dropmat1, rock1){
  tile.value=numeric()
  n = dim(dropmat1)[1]
  mytile.value=dropmat1[ifelse(tile%%n==0, tile%/%n, tile%/%n+1), ifelse(tile%%n==0,n,
    tile%%n)]
  direc = direcflow(tile, dropmat1, rock1)
  if(length(direc)==0) {return(dropmat1)}
  for(i in direc){
    tile.value= c(tile.value,dropmat1[ifelse(i%%n==0, i%/%n, i%/%n+1), 
      ifelse(i%%n==0,n,i%%n)])
  }
  avg.value = mean(c(mytile.value, tile.value))
  excess.drop = mytile.value - avg.value
  allocated.drop = excess.drop / rate1
  final.drop = allocated.drop / rate2
  dropmat1[ifelse(tile%%n==0, tile%/%n, tile%/%n+1), ifelse(tile%%n==0,n, tile%%n)] =
    mytile.value - final.drop  
  
    alloc.drop = (mytile.value - tile.value) / sum(mytile.value - tile.value)
  for(i in 1:length(direc)){
    j = direc[i]
    dropmat1[ifelse(j%%n==0, j%/%n, j%/%n+1), ifelse(j%%n==0,n,j%%n)] = 
      (dropmat1[ifelse(j%%n==0, j%/%n, j%/%n+1), ifelse(j%%n==0,n,j%%n)] + 
         final.drop * alloc.drop[i])
  }
  return (dropmat1)
}

# this function runs one.small.time.flow on all the times. It turns it multiple times--
# exactly rate2 times. Hence, the idea is to simulate flows over 1 "big time"
one.big.time.flow = function(dropmat1, rate1=2, rate2=30, rock1){
  for(i in 1:rate2){
    for(tile in 1:dim(dropmat1)[1]^2){
      dropmat1 = one.small.time.flow(tile, rate1, rate2, dropmat1=dropmat1, rock1)
    }
  }
  return(dropmat1)
}

# this is 1 "big time." First at the new rain. Then, simulate the flow of water
# over 1 "big time"
one.cycle=function(dropmat1, cloudvec, raindrops=2, rate1=1, rate2=60, rock1){
  dropmat1=cloud(dropmat1, cloudvec,raindrops)
  dropmat1 = one.big.time.flow(dropmat1=dropmat1, rate1=rate1, rate2=rate2, rock1)
  return(dropmat1)  
}

# actually draws the cool pictures we see. Included is a legend showing the 
# number of raindrops. Also, inputs the color we want. "Blue" vector is user-generated
# and it can be any color.
draw.rain = function(drop, blue){
  plot(0:(n+1), 0:(n+1), type='n', xlab="",ylab="", main="Rain Simulator")
  legend(legend = c("~5","~15","~25","~35","~45"), title = "# Drops",
         fill = blue[seq(5,45, length=5)], "topright")
  for(i in 1:n^2){
    value = drop[ifelse(i%%n==0, i%/%n, i%/%n+1), ifelse(i%%n==0,n,i%%n)]
    rect(ifelse(i%%n==0,n,i%%n)-1, n-ifelse(i%%n==0, i%/%n, i%/%n+1), 
         ifelse(i%%n==0,n,i%%n), n-ifelse(i%%n==0, i%/%n, i%/%n+1)+1, col =
           ifelse(value < 50, blue[as.integer(value)], blue[length(blue)]))
  }
}



# User-generated steps

# specify the n * n grid
n=15

# creates the matrix to determine adjacent tiles for the first and second functions
# written above
jumpmat=grid.maker(n)

# our color vector
blue = rgb(seq(1,0,length=50), seq(1, 0, length=50), seq(1,.7,length=50))
# to make weird colors:
# blue = rainbow(50) 

# matrix containing the values of water drops in each tile
drop=matrix(rep(0,n^2),ncol=n)

# the vector containing the tiles for your cloud, letters work on 5 * 5 grid
cloudvec =c(14,15,16)
Ecloudvec = c(2,3,4,7,12,13, 17,22,23,24)
Tcloudvec = c(1,2,3,4,5,8,13,18,23)
Ycloudvec = c(1,5,7,9,13,18,23)
Wcloudvec = c(15,21,23,25,27,31,33) # only works on 7 * 7 grid
Hcloudvec = c(17,19,32,34,47,48,49,62,64,77,79)
E1cloudvec = c(21,22,23,36,51,52,66,81,82,83)
L1cloudvec = c(25,40,55,70,85,86)
L2cloudvec = c(28,43,58,73,88,89)
Ocloudvec = c(108,109,110,111,112,113,114,123,129,138,144,153,159,168,174,183,189,198,
  199,200,201,202,203,204)
signcloudvec = c(116,117,131,132,146,147,161,162,191,192,206,207)

rock=c(33, 63)

dropmaze=c(98,128)
rockmaze = c(16,17,18,19,20,21,22,23,24,25,26,27,28,29,
                 47,48,49,50,51,52,53,54,55,56,57,58,59,60,
              76,77,78,79,80,81,82,83,84,85,86,87,88,89,
          107,108,109,110,111,112,113,114,115,116,117,118,119,120,
          136,137,138,139,140,141,142,143,144,145,146,147,148,149,
              167,168,169,170,171,172,173,174,175,176,177,178,179,180,
          196,197,198,199,200,201,202,203,204,205,206,207,208,209)

dropsigma = c(165)
rocksigma = c(16,
              31,32,      35,36,37,38,39,40,41,42,43,44,
                 47,48,      51,52,                  59,60,
                    63,64,      67,68,
                       79,80,      83,84,85,
                          95,96,         100,
                         110,111,        114,115,
                     124,125,        128,129,
                 138,139,        142,143,                    149,150,
             152,153,        156,157,                    163,164,165,
         166,167,        170,171,                    177,178,
         181,        184,185,186,187,188,189,190,191,192)


dropspiral=c(113,129)
rockspiral=c(              4, 5,                  11,12,13,
                          17,18,19,                     28,29,
                       31,32,         36,37,38,39,40,      44,45,
                       46,         50,51,52,53,54,55,56,      60,
                       61,      64,65,66,            71,72,
                             78,79,                     87,88,
                             93,         97,98,99,        103,104, 
                           108,        111,112,    114,115,            119,120,
                           123,        126,127,128,    130,131,        134,145,
                       137,138,        141,142,        145,            149,
                           153,154,                159,160,        163,164,
                   166,        169,170,        173,174,        177,178,
                   181,182,        185,186,187,188,            192,
                       197,198,                            206,207,
                           213,214,            218,219,220,221)



# running the program and drawing the pictures. Stop motion in statistics!
# in this loop, the picture should update at precisely every 5 seconds.
# if the grid is large (10 * 10), then need to increase Sys.sleep from 5 to a larger
# number to allow time for computations. Or else will receive "rversion" error.
# In this example, there are 10 "big times", rate1 is 2, rate3 is 60. Cloudvec
# can be changed to draw whatever you like.  



for(i in 1:3){
  pmt = system.time((drop = one.cycle(dropmat1=drop, cloudvec=L1cloudvec, raindrops=30, 
      rate1=35, rate2=1, rock1=rock)))
  draw.rain(drop, blue)
  Sys.sleep(3-pmt[3])
}
for(i in 1:3){
  pmt = system.time((drop = one.cycle(dropmat1=drop, cloudvec=Hcloudvec, raindrops=30, 
      rate1=35, rate2=1, rock1=rock)))
  draw.rain(drop, blue)
  Sys.sleep(3-pmt[3])
}
for(i in 1:3){
  pmt = system.time((drop = one.cycle(dropmat1=drop, cloudvec=L2cloudvec, raindrops=30, 
      rate1=35, rate2=1, rock1=rock)))
  draw.rain(drop, blue)
  Sys.sleep(3-pmt[3])
}
for(i in 1:3){
  pmt = system.time((drop = one.cycle(dropmat1=drop, cloudvec=E1cloudvec, raindrops=30, 
      rate1=35, rate2=1, rock1=rock)))
  draw.rain(drop, blue)
  Sys.sleep(3-pmt[3])
}
for(i in 1:3){
  pmt = system.time((drop = one.cycle(dropmat1=drop, cloudvec=Ocloudvec, raindrops=30, 
      rate1=35, rate2=1, rock1=rock)))
  draw.rain(drop, blue)
  Sys.sleep(3-pmt[3])
}
for(i in 1:3){
  pmt = system.time((drop = one.cycle(dropmat1=drop, cloudvec=signcloudvec, raindrops=30, 
      rate1=35, rate2=1, rock1=rock)))
  draw.rain(drop, blue)
  Sys.sleep(3-pmt[3])
}

for(i in 1:10){
  pmt = system.time((drop = one.cycle(dropmat1=drop, cloudvec=signcloudvec, raindrops=0, 
      rate1=1.5, rate2=30, rock1=rock)))
  draw.rain(drop, blue)
  Sys.sleep(3-pmt[3])
}


# resets dropmatrix to just zeros. There is no more water.
drop=matrix(rep(0,n^2),ncol=n)



for(i in 1:20){
  pmt = system.time((drop = one.cycle(dropmat1=drop, cloudvec=dropmaze, raindrops=150, 
                                      rate1=.05, rate2=20, rock1=rockmaze)))
  draw.rain(drop, blue)
  Sys.sleep(2-pmt[3])
}

for(i in 1:10){
  pmt = system.time((drop = one.cycle(dropmat1=drop, cloudvec=dropmaze, raindrops=0, 
                                      rate1=.01, rate2=50, rock1=rockmaze)))
  draw.rain(drop, blue)
  Sys.sleep(2-pmt[3])
}

# resets dropmatrix to just zeros. There is no more water.
drop=matrix(rep(0,n^2),ncol=n)



for(i in 1:10){
  pmt = system.time((drop = one.cycle(dropmat1=drop, cloudvec=dropsigma, raindrops=300, 
                                      rate1=.05, rate2=10, rock1=rocksigma)))
  draw.rain(drop, blue)
  Sys.sleep(2-pmt[3])
}

for(i in 1:10){
  pmt = system.time((drop = one.cycle(dropmat1=drop, cloudvec=dropsigma, raindrops=0, 
                                      rate1=.01, rate2=50, rock1=rocksigma)))
  draw.rain(drop, blue)
  Sys.sleep(2-pmt[3])
}

# resets dropmatrix to just zeros. There is no more water.
drop=matrix(rep(0,n^2),ncol=n)




for(i in 1:10){
  pmt = system.time((drop = one.cycle(dropmat1=drop, cloudvec=dropspiral, raindrops=300, 
                                      rate1=.05, rate2=10, rock1=rockspiral)))
  draw.rain(drop, blue)
  Sys.sleep(2-pmt[3])
}

for(i in 1:10){
  pmt = system.time((drop = one.cycle(dropmat1=drop, cloudvec=dropspiral, raindrops=0, 
                                      rate1=0.01, rate2=50, rock1=rockspiral)))
  draw.rain(drop, blue)
  Sys.sleep(2-pmt[3])
}



drop

# resets dropmatrix to just zeros. There is no more water.
drop=matrix(rep(0,n^2),ncol=n)
#extra stuff to take a look at
#plot(as.vector(drop))
#drop


# Disclaimer: simulation works up to 50 raindrops per tile. Otherwise, the coding of
# the colors has to be changed to allow a higher range.


# Miscellaneous code that aren't required for the program
"""
image(matrix(seq(1:49),7,7),col=rgb(seq(1,.00,length=49),
  seq(1,0,length=49), seq(1,.7,length=49)),axes=FALSE);

draw.animation = function(){
  drop = one.cycle(dropmat1=drop, cloudvec=cloudvec, raindrops=10, rate1=2, rate2=60)
  image(drop, col = blue, axes=FALSE)
  Sys.sleep(5)
  return(drop)
}
for(i in 1:100){
  drop = draw.animation()
}

"""
#plot(as.vector(drop),type="l")
"""dev.off()
plot.new()
"""
#rect(0, 0, 1, 1, col="red")
"""
col=rainbow(11, start=.7,end=.1))
col=heat.colors(11)

n=10
x=0:(n+1)
y=0:(n+1)

# xleft,ybot,xright,ytop
plot(x, y, type='n') 
for(i in 1:n^2){
  rect(ifelse(i%%n==0,n,i%%n)-1, n-ifelse(i%%n==0, i%/%n, i%/%n+1), ifelse(i%%n==0,n,i%%n),
       n-ifelse(i%%n==0, i%/%n, i%/%n+1)+1, col=blue[i])
}


rainbow(n^2)

rCols= rainbow(n, alpha= .25)
brCols = rCols[br5]
"""
#legend(legend = 1:n, fill = rCols, "topright")
"""
i is the number for the tile
x=ifelse(i%%n==0, i%/%n, i%/%n+1)
y=ifelse(i%%n==0,n,i%%n)
xleft= ifelse(i%%n==0,n,i%%n)-1
xright=ifelse(i%%n==0,n,i%%n)
ybot=n-ifelse(i%%n==0, i%/%n, i%/%n+1)
ytop=n-ifelse(i%%n==0, i%/%n, i%/%n+1)+1
"""